<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Realistic Earth — Final</title>
  <style>
    html,body { height:100%; margin:0; background:#000; overflow:hidden; font-family: Inter, system-ui, sans-serif;}
    #ui { position:fixed; z-index:3; right:18px; top:18px; color:#fff; font-size:13px; background:rgba(0,0,0,0.25); padding:8px 12px; border-radius:8px; backdrop-filter: blur(4px); }
    a { color:#9ad; text-decoration:none; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="ui">Tip: drag to rotate • scroll to zoom • <a href="#" id="toggleAuto">toggle auto-rotate</a></div>
  <canvas id="c"></canvas>

  <!-- module imports via importmap -->
  <script async src="https://unpkg.com/es-module-shims@1.8.1/dist/es-module-shims.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
  import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
  import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
  import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';

  // -- canvas + renderer
  const canvas = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.setSize(innerWidth, innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;

  // -- scene + camera
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 8000);
  camera.position.set(0, 2.5, 18);

  // -- controls
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.minDistance = 7;
  controls.maxDistance = 50;
  controls.autoRotate = true;
  controls.autoRotateSpeed = 0.3;

  document.getElementById('toggleAuto').addEventListener('click', (e)=>{
    e.preventDefault();
    controls.autoRotate = !controls.autoRotate;
    e.target.textContent = controls.autoRotate ? 'auto-rotate: on' : 'auto-rotate: off';
  });

  // -- loaders and stable texture sources
  const tloader = new THREE.TextureLoader();

  // NOTE: using stable threejs example assets + rawcdn for earth lights
  const TEX_DAY    = 'https://threejs.org/examples/textures/land_ocean_ice_cloud_2048.jpg';
  const TEX_NIGHT  = 'https://rawcdn.githack.com/trekhleb/machine-learning-experiments/gh-pages/threejs/textures/earth_lights_2048.png';
  const TEX_SPEC   = 'https://threejs.org/examples/textures/earth_specular_2048.jpg';
  const TEX_BUMP   = 'https://threejs.org/examples/textures/earthbump1k.jpg';
  const TEX_CLOUDS = 'https://threejs.org/examples/textures/earth_clouds_1024.png';
  const TEX_MOON   = 'https://threejs.org/examples/textures/moon_1024.jpg'; // fallback moon texture
  const CUBE_PATH  = 'https://threejs.org/examples/textures/cube/MilkyWay/';

  // load textures
  const [mapDay, mapNight, mapSpec, mapBump, mapClouds] = await Promise.all([
    tloader.loadAsync(TEX_DAY),
    tloader.loadAsync(TEX_NIGHT),
    tloader.loadAsync(TEX_SPEC),
    tloader.loadAsync(TEX_BUMP),
    tloader.loadAsync(TEX_CLOUDS)
  ]);

  // anisotropy
  const maxAniso = Math.min(renderer.capabilities.getMaxAnisotropy(), 8);
  [mapDay, mapNight, mapSpec, mapBump, mapClouds].forEach(t=>{ if(t) t.anisotropy = maxAniso; });

  // -- background cube (Milky Way) for cinematic depth
  const urls = [
    CUBE_PATH + 'dark-s_px.jpg',
    CUBE_PATH + 'dark-s_nx.jpg',
    CUBE_PATH + 'dark-s_py.jpg',
    CUBE_PATH + 'dark-s_ny.jpg',
    CUBE_PATH + 'dark-s_pz.jpg',
    CUBE_PATH + 'dark-s_nz.jpg'
  ];
  const cubeTex = new THREE.CubeTextureLoader().load(urls);
  cubeTex.encoding = THREE.sRGBEncoding;
  scene.background = cubeTex;

  // -- Sun (Directional light) + subtle fill
  const sun = new THREE.DirectionalLight(0xffffff, 2.2);
  sun.position.set(120, 40, 80);
  scene.add(sun);

  const fill = new THREE.AmbientLight(0x111517, 0.4);
  scene.add(fill);

  // add lens flare to the sun for cinematic feel
  const flareTex0 = await tloader.loadAsync('https://threejs.org/examples/textures/lensflare/lensflare0.png');
  const flareTex3 = await tloader.loadAsync('https://threejs.org/examples/textures/lensflare/lensflare3.png');
  const lf = new Lensflare();
  lf.addElement(new LensflareElement(flareTex0, 600, 0.0, sun.color));
  lf.addElement(new LensflareElement(flareTex3, 120, 0.35));
  lf.addElement(new LensflareElement(flareTex3, 60, 0.6));
  sun.add(lf);

  // -- Earth: geometry + advanced materials (day+night blended)
  const earthGeo = new THREE.SphereGeometry(5, 256, 256);

  // Day material (Phong for specular highlights on oceans)
  const matDay = new THREE.MeshPhongMaterial({
    map: mapDay,
    specularMap: mapSpec,
    specular: new THREE.Color(0x444444),
    shininess: 18,
    bumpMap: mapBump,
    bumpScale: 0.04
  });

  // Night overlay via custom shader: night map appears only on dark side (smooth terminator)
  const nightUniforms = {
    nightTex: { value: mapNight },
    sunDir:   { value: new THREE.Vector3().copy(sun.position).normalize() },
    boost:    { value: 1.25 }
  };

  const matNight = new THREE.ShaderMaterial({
    uniforms: nightUniforms,
    vertexShader: `
      varying vec2 vUv;
      varying vec3 vNormalW;
      void main(){
        vUv = uv;
        vNormalW = normalize(mat3(modelMatrix) * normal);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
      }
    `,
    fragmentShader: `
      uniform sampler2D nightTex;
      uniform vec3 sunDir;
      uniform float boost;
      varying vec2 vUv;
      varying vec3 vNormalW;
      void main(){
        float ndl = dot(normalize(vNormalW), normalize(sunDir));
        float nightFactor = smoothstep(0.14, -0.06, ndl); // adjust to get soft terminator
        vec3 col = texture2D(nightTex, vUv).rgb;
        col = pow(col, vec3(1.15)) * boost;
        gl_FragColor = vec4(col * nightFactor, nightFactor);
      }
    `,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  const earthDay = new THREE.Mesh(earthGeo, matDay);
  scene.add(earthDay);
  const earthNight = new THREE.Mesh(earthGeo, matNight);
  scene.add(earthNight);

  // -- Clouds: textured layer with subtle scattering & noise via alpha
  const cloudGeo = new THREE.SphereGeometry(5.03, 256, 256);
  const cloudMat = new THREE.MeshPhongMaterial({
    map: mapClouds,
    transparent: true,
    opacity: 0.42,
    depthWrite: false,
    shininess: 2
  });
  const clouds = new THREE.Mesh(cloudGeo, cloudMat);
  scene.add(clouds);

  // -- Atmosphere: approximate Rayleigh scattering shader (soft, realistic rim)
  const atmoGeo = new THREE.SphereGeometry(5.18, 128, 128);
  const atmoMat = new THREE.ShaderMaterial({
    uniforms: {
      coef: { value: 0.9 },
      power: { value: 2.2 },
      glowColor: { value: new THREE.Vector3(0.35, 0.6, 1.0) },
      cameraPos: { value: camera.position }
    },
    vertexShader: `
      varying vec3 vNormalW;
      varying vec3 vPosW;
      void main() {
        vNormalW = normalize(mat3(modelMatrix) * normal);
        vPosW = (modelMatrix * vec4(position,1.0)).xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 glowColor;
      uniform float coef;
      uniform float power;
      varying vec3 vNormalW;
      varying vec3 vPosW;
      void main(){
        vec3 viewDir = normalize(cameraPosition - vPosW);
        float rim = 1.0 - max(dot(normalize(vNormalW), viewDir), 0.0);
        rim = pow(rim * coef, power);
        // subtle color falloff
        vec3 col = glowColor * rim;
        float alpha = rim * 0.6;
        gl_FragColor = vec4(col, alpha);
      }
    `,
    blending: THREE.AdditiveBlending,
    side: THREE.BackSide,
    transparent: true,
    depthWrite: false
  });
  const atmosphere = new THREE.Mesh(atmoGeo, atmoMat);
  scene.add(atmosphere);

  // -- Moon (detailed, lit by same Sun)
  const moonTex = await tloader.loadAsync(TEX_MOON).catch(()=>null);
  const moonGeo = new THREE.SphereGeometry(1.25, 128, 128);
  const moonMat = new THREE.MeshStandardMaterial({
    map: moonTex || mapBump,
    roughness: 1.0,
    metalness: 0.0
  });
  const moon = new THREE.Mesh(moonGeo, moonMat);
  // place moon above earth's horizon on right
  moon.position.set(8.2, 6.4, -2.0);
  scene.add(moon);

  // -- Small crater shading (add subtle displacement via normalMap if available) - optional

  // -- Starfield points (procedural with twinkle)
  const starGeo = new THREE.BufferGeometry();
  const starCount = 8000;
  const pos = new Float32Array(starCount * 3);
  for (let i=0;i<starCount;i++){
    const phi = Math.acos(2*Math.random()-1);
    const theta = 2*Math.PI*Math.random();
    const r = 1600 + Math.random()*1000;
    const ix = i*3;
    pos[ix]   = r * Math.sin(phi) * Math.cos(theta);
    pos[ix+1] = r * Math.sin(phi) * Math.sin(theta);
    pos[ix+2] = r * Math.cos(phi);
  }
  starGeo.setAttribute('position', new THREE.BufferAttribute(pos,3));
  const starMat = new THREE.PointsMaterial({ size: 0.6, color: 0xffffff, transparent:true, opacity:0.88, depthWrite:false });
  const stars = new THREE.Points(starGeo, starMat);
  scene.add(stars);

  // -- Postprocessing: composer + bloom + FXAA
  const composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));
  const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.28, 0.6, 0.85);
  bloom.threshold = 0.82;
  bloom.strength = 0.28;
  bloom.radius = 0.6;
  composer.addPass(bloom);

  // FXAA pass
  const fxaa = new ShaderPass(FXAAShader);
  fxaa.uniforms['resolution'].value.set(1 / innerWidth, 1 / innerHeight);
  composer.addPass(fxaa);

  // -- Resize helper
  window.addEventListener('resize', onWindowResize, false);
  function onWindowResize(){
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    composer.setSize(innerWidth, innerHeight);
    fxaa.uniforms['resolution'].value.set(1/innerWidth, 1/innerHeight);
  }

  // -- Animation loop
  let clock = new THREE.Clock();
  function render(){
    requestAnimationFrame(render);
    const dt = clock.getDelta();

    // rotate earth & clouds (soft)
    earthDay.rotation.y += dt * 0.04;       // ~0.04 rad/s scaled for visual
    earthNight.rotation.y = earthDay.rotation.y;
    clouds.rotation.y += dt * 0.06;
    // moon slowly orbits a tiny bit (cosmetic)
    moon.rotation.y += dt * 0.02;

    // twinkle stars
    const t = performance.now() * 0.0005;
    starMat.opacity = 0.82 + Math.sin(t*1.7)*0.04;

    // update night shader sun direction
    nightUniforms.sunDir.value.copy(sun.position).normalize();

    controls.update();
    composer.render(dt);
  }
  render();

  // -- quick debug: log GPU / renderer warnings if textures blocked
  function checkTextureLoad(){
    if(!mapDay || !mapNight){ console.warn('Some textures not loaded — consider running via local server (http) to avoid CORS/file issues)'); }
  }
  checkTextureLoad();

  // -- End module
  </script>
</body>
</html>